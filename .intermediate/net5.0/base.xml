<?xml version="1.0"?>
<doc>
    <assembly>
        <name>base</name>
    </assembly>
    <members>
        <member name="F:Sandbox.DecalDefinition.ByPath">
            <summary>
            A dictionary of 
            </summary>
        </member>
        <member name="M:Sandbox.DecalDefinition.PlaceUsingTrace(Sandbox.TraceResult)">
            <summary>
            Place this decal somewhere
            </summary>
        </member>
        <member name="M:Sandbox.DevCamera.Activated">
            <summary>
            On the camera becoming activated, snap to the current view position
            </summary>
        </member>
        <member name="P:Sandbox.LookAtCamera.Origin">
            <summary>
            Origin of the camera
            </summary>
        </member>
        <member name="P:Sandbox.LookAtCamera.TargetEntity">
            <summary>
            Entity to look at
            </summary>
        </member>
        <member name="P:Sandbox.LookAtCamera.TargetOffset">
            <summary>
            Offset from the entity to look at
            </summary>
        </member>
        <member name="P:Sandbox.LookAtCamera.MinFov">
            <summary>
            Min fov when target is max distance away from origin
            </summary>
        </member>
        <member name="P:Sandbox.LookAtCamera.MaxFov">
            <summary>
            Max fov when target is near the origin
            </summary>
        </member>
        <member name="P:Sandbox.LookAtCamera.MinFovDistance">
            <summary>
            How far away to reach min fov
            </summary>
        </member>
        <member name="P:Sandbox.LookAtCamera.LerpSpeed">
            <summary>
            How quick to lerp to target
            </summary>
        </member>
        <member name="T:Sandbox.BaseCarriable">
            <summary>
            An entity that can be carried in the player's inventory and hands.
            </summary>
        </member>
        <member name="M:Sandbox.BaseCarriable.ActiveStart(Sandbox.Entity)">
            <summary>
            This entity has become the active entity. This most likely
            means a player was carrying it in their inventory and now
            has it in their hands.
            </summary>
        </member>
        <member name="M:Sandbox.BaseCarriable.ActiveEnd(Sandbox.Entity,System.Boolean)">
            <summary>
            This entity has stopped being the active entity. This most
            likely means a player was holding it but has switched away
            or dropped it (in which case dropped = true)
            </summary>
        </member>
        <member name="M:Sandbox.BaseCarriable.CreateViewModel">
            <summary>
            Create the viewmodel. You can override this in your base classes if you want
            to create a certain viewmodel entity.
            </summary>
        </member>
        <member name="M:Sandbox.BaseCarriable.DestroyViewModel">
            <summary>
            We're done with the viewmodel - delete it
            </summary>
        </member>
        <member name="P:Sandbox.BaseCarriable.EffectEntity">
            <summary>
            Utility - return the entity we should be spawning particles from etc
            </summary>
        </member>
        <member name="T:Sandbox.BaseViewModel">
            <summary>
            A common base we can use for weapons so we don't have to implement the logic over and over
            again.
            </summary>
        </member>
        <member name="T:Sandbox.BaseWeapon">
            <summary>
            A common base we can use for weapons so we don't have to implement the logic over and over
            again. Feel free to not use this and to implement it however you want to.
            </summary>
        </member>
        <member name="M:Sandbox.BaseWeapon.TraceBullet(Vector3,Vector3,System.Single)">
            <summary>
            Does a trace from start to end, does bullet impact effects. Coded as an IEnumerable so you can return multiple
            hits, like if you're going through layers or ricocet'ing or something.
            </summary>
        </member>
        <member name="P:Sandbox.Camera.Viewer">
            <summary>
            If this is set, we won't draw the third person model for this entity
            </summary>
        </member>
        <member name="P:Sandbox.Camera.DoFPoint">
            <summary>
            Length until the Depth of Field focus point
            </summary>
        </member>
        <member name="P:Sandbox.Camera.DoFBlurSize">
            <summary>
            How big is the DoF aperture, in pixels
            </summary>
        </member>
        <member name="P:Sandbox.Camera.ViewModelFieldOfView">
            <summary>
            Viewmodel specific setup
            </summary>
        </member>
        <member name="P:Sandbox.Camera.Ortho">
            <summary>
            Use orthographic projection
            </summary>
        </member>
        <member name="P:Sandbox.Camera.OrthoSize">
            <summary>
            Acts as a zoom when ortho is enabled 
            </summary>
        </member>
        <member name="M:Sandbox.Camera.BuildInput(Sandbox.InputBuilder)">
            <summary>
            This builds the default behaviour for our input
            </summary>
        </member>
        <member name="M:Sandbox.Camera.Activated">
            <summary>
            Camera has become the active camera. You can use this as an opportunity
            to snap the positions if you're lerping etc.
            </summary>
        </member>
        <member name="M:Sandbox.Camera.Deactivated">
            <summary>
            Camera has stopped being the active camera.
            </summary>
        </member>
        <member name="M:Sandbox.Hammer.BaseTrigger.OnStartTouch(Sandbox.Entity)">
            <summary>
            An entity that passes PassesTriggerFilters has started touching the trigger
            </summary>
        </member>
        <member name="M:Sandbox.Hammer.BaseTrigger.OnEndTouch(Sandbox.Entity)">
            <summary>
            An entity that started touching this trigger has stopped touching
            </summary>
        </member>
        <member name="M:Sandbox.Hammer.BaseTrigger.PassesTriggerFilters(Sandbox.Entity)">
            <summary>
            Determine if an entity should be allowed to touch this trigger
            </summary>
        </member>
        <member name="M:Sandbox.FuncButton.OnUse(Sandbox.Entity)">
            <summary>
            A player has pressed this
            </summary>
        </member>
        <member name="M:Sandbox.FuncButtonRotating.OnUse(Sandbox.Entity)">
            <summary>
            A player has pressed this
            </summary>
        </member>
        <member name="M:Sandbox.FuncDoor.OnUse(Sandbox.Entity)">
            <summary>
            A player has pressed this
            </summary>
        </member>
        <member name="T:Sandbox.KeyframeEntity">
            <summary>
            An entity that is moved programatically. Like an elevator
            or a kliner smashing star wars garbage compactor
            </summary>
        </member>
        <member name="M:Sandbox.KeyframeEntity.TryKeyframeTo(Transform)">
            <summary>
            Try to move to this position.
            </summary>
        </member>
        <member name="T:Sandbox.HudEntity`1">
            <summary>
            A base HUD entity that lets you define which type of RootPanel to create.
            </summary>
        </member>
        <member name="M:Sandbox.HudEntity`1.CreateRootPanel">
            <summary>
            Create the root panel, T
            </summary>
        </member>
        <member name="M:Sandbox.PawnAnimator.SetLookAt(System.String,Vector3)">
            <summary>
            We'll convert Position to a local position to the players eyes and set
            the param on the animgraph.
            </summary>
        </member>
        <member name="M:Sandbox.PawnAnimator.SetParam(System.String,Vector3)">
            <summary>
            Sets the param on the animgraph
            </summary>
        </member>
        <member name="M:Sandbox.PawnAnimator.SetParam(System.String,System.Single)">
            <summary>
            Sets the param on the animgraph
            </summary>
        </member>
        <member name="M:Sandbox.PawnAnimator.SetParam(System.String,System.Boolean)">
            <summary>
            Sets the param on the animgraph
            </summary>
        </member>
        <member name="M:Sandbox.PawnAnimator.SetParam(System.String,System.Int32)">
            <summary>
            Sets the param on the animgraph
            </summary>
        </member>
        <member name="M:Sandbox.PawnAnimator.Trigger(System.String)">
            <summary>
            Calls SetParam( name, true ). It's expected that your animgraph
            has a "name" param with the auto reset property set.
            </summary>
        </member>
        <member name="M:Sandbox.PawnAnimator.ResetParams">
            <summary>
            Resets all params to default values on the animgraph
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.Simulate">
            <summary>
            This is what your logic should be going in
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.FrameSimulate">
            <summary>
            This is called every frame on the client only
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.RunEvents(Sandbox.PawnController)">
            <summary>
            Call OnEvent for each event
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.OnEvent(System.String)">
            <summary>
            An event has been triggered - maybe handle it
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.HasEvent(System.String)">
            <summary>
            Returns true if we have this event
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.HasTag(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.AddEvent(System.String)">
            <summary>
            Allows the controller to pass events to other systems
            while staying abstracted.
            For example, it could pass a "jump" event, which could then
            be picked up by the playeranimator to trigger a jump animation,
            and picked up by the player to play a jump sound.
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.SetTag(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Sandbox.PawnController.BuildInput(Sandbox.InputBuilder)">
            <summary>
            Allow the controller to tweak input. Empty by default
            </summary>
        </member>
        <member name="T:Sandbox.Player">
            <summary>
            This is what you should derive your player from. This base exists in addon code
            so we can take advantage of codegen for replication. The side effect is that we
            can put stuff in here that we don't need to access from the engine - which gives
            more transparency to our code.
            </summary>
        </member>
        <member name="P:Sandbox.Player.Controller">
            <summary>
            The PlayerController takes player input and moves the player. This needs
            to match between client and server. The client moves the local player and
            then checks that when the server moves the player, everything is the same.
            This is called prediction. If it doesn't match the player resets everything
            to what the server did, that's a prediction error.
            You should really never manually set this on the client - it's replicated so
            that setting the class on the server will automatically network and set it 
            on the client.
            </summary>
        </member>
        <member name="P:Sandbox.Player.DevController">
            <summary>
            This is used for noclip mode
            </summary>
        </member>
        <member name="M:Sandbox.Player.GetActiveController">
            <summary>
            Return the controller to use. Remember any logic you use here needs to match
            on both client and server. This is called as an accessor every tick.. so maybe
            avoid creating new classes here or you're gonna be making a ton of garbage!
            </summary>
        </member>
        <member name="P:Sandbox.Player.Animator">
            <summary>
            The player animator is responsible for positioning/rotating the player and 
            interacting with the animation graph.
            </summary>
        </member>
        <member name="M:Sandbox.Player.GetActiveAnimator">
            <summary>
            Return the controller to use. Remember any logic you use here needs to match
            on both client and server. This is called as an accessor every tick.. so maybe
            avoid creating new classes here or you're gonna be making a ton of garbage!
            </summary>
        </member>
        <member name="M:Sandbox.Player.Simulate(Sandbox.Client)">
            <summary>
            Called every tick to simulate the player. This is called on the
            client as well as the server (for prediction). So be careful!
            </summary>
        </member>
        <member name="M:Sandbox.Player.OnKilled">
            <summary>
            Called once the player's health reaches 0
            </summary>
        </member>
        <member name="M:Sandbox.Player.Respawn">
            <summary>
            Sets LifeState to Alive, Health to Max, nulls velocity, and calls Gamemode.PlayerRespawn
            </summary>
        </member>
        <member name="M:Sandbox.Player.CreateHull">
            <summary>
            Create a physics hull for this player. The hull stops physics objects and players passing through
            the player. It's basically a big solid box. It also what hits triggers and stuff.
            The player doesn't use this hull for its movement size.
            </summary>
        </member>
        <member name="M:Sandbox.Player.BuildInput(Sandbox.InputBuilder)">
            <summary>
            Called from the gamemode, clientside only.
            </summary>
        </member>
        <member name="P:Sandbox.Player.Corpse">
            <summary>
            A generic corpse entity
            </summary>
        </member>
        <member name="M:Sandbox.Player.PostCameraSetup(Sandbox.CameraSetup@)">
            <summary>
            Called after the camera setup logic has run. Allow the player to 
            do stuff to the camera, or using the camera. Such as positioning entities 
            relative to it, like viewmodels etc.
            </summary>
        </member>
        <member name="M:Sandbox.Player.OnAnimEventFootstep(Vector3,System.Int32,System.Single)">
            <summary>
            A foostep has arrived!
            </summary>
        </member>
        <member name="P:Sandbox.Player.LastActiveChild">
            <summary>
            This isn't networked, but it's predicted. If it wasn't then when the prediction system
            re-ran the commands LastActiveChild would be the value set in a future tick, so ActiveEnd
            and ActiveStart would get called mulitple times and out of order, causing all kinds of pain.
            </summary>
        </member>
        <member name="M:Sandbox.Player.SimulateActiveChild(Sandbox.Client,Sandbox.Entity)">
            <summary>
            Simulated the active child. This is important because it calls ActiveEnd and ActiveStart.
            If you don't call these things, viewmodels and stuff won't work, because the entity won't
            know it's become the active entity.
            </summary>
        </member>
        <member name="M:Sandbox.Player.OnActiveChildChanged(Sandbox.Entity,Sandbox.Entity)">
            <summary>
            Called when the Active child is detected to have changed
            </summary>
        </member>
        <member name="M:Sandbox.Player.TickPlayerUse">
            <summary>
            This should be called somewhere in your player's tick to allow them to use entities
            </summary>
        </member>
        <member name="M:Sandbox.Player.UseFail">
            <summary>
            Player tried to use something but there was nothing there.
            Tradition is to give a dissapointed boop.
            </summary>
        </member>
        <member name="M:Sandbox.Player.StopUsing">
            <summary>
            If we're using an entity, stop using it
            </summary>
        </member>
        <member name="M:Sandbox.Player.FindUsable">
            <summary>
            Find a usable entity for this player to use
            </summary>
        </member>
        <member name="T:Sandbox.Prop">
            <summary>
            Your standard prop
            </summary>
        </member>
        <member name="T:Sandbox.Sky">
            <summary>
            Simple Skybox
            </summary>
        </member>
        <member name="T:Sandbox.AtmosphereSky">
            <summary>
            Fancy dynamic sky
            </summary>
        </member>
        <member name="T:Sandbox.PickupTrigger">
            <summary>
            A utilty class. Add as a child to your pickupable entities to expand
            the trigger boundaries. They'll be able to pick up the parent entity
            using these bounds.
            </summary>
        </member>
        <member name="M:Sandbox.PickupTrigger.SetTriggerSize(System.Single)">
            <summary>
            Set the trigger radius. Default is 16.
            </summary>
        </member>
        <member name="M:Sandbox.EntityExtensions.CopyBonesFrom(Sandbox.Entity,Sandbox.Entity)">
            <summary>
            Copy the bones from the target entity, but at the current entity's position and rotation
            </summary>
        </member>
        <member name="M:Sandbox.EntityExtensions.CopyBonesFrom(Sandbox.Entity,Sandbox.Entity,Vector3,Rotation,System.Single)">
            <summary>
            Copy the bones from the target entity, but at this position and rotation instead of the target entity's
            </summary>
        </member>
        <member name="M:Sandbox.EntityExtensions.SetRagdollVelocityFrom(Sandbox.Entity,Sandbox.Entity,System.Single,System.Single,System.Single)">
            <summary>
            Set the velocity of the ragdoll entity by working out the bone positions of from delta seconds ago 
            </summary>
        </member>
        <member name="T:Sandbox.ModelExtensions">
            <summary>
            Extensions for Model
            </summary>
        </member>
        <member name="M:Sandbox.ModelExtensions.GetBreakPieces(Sandbox.Model)">
            <summary>
            Get a list of break pieces for this model. These are stored in the "break_list" data key.
            </summary>
        </member>
        <member name="M:Sandbox.ModelExtensions.GetPropData(Sandbox.Model)">
            <summary>
            Get prop data for this model. This is stored in the "prop_data" data key.
            </summary>
        </member>
        <member name="M:Sandbox.ModelExtensions.GetExplosionBehavior(Sandbox.Model)">
            <summary>
            Get explosion behavior for this model. This is stored in the "explosion_behavior" data key.
            </summary>
        </member>
        <member name="M:Sandbox.ModelExtensions.HasExplosionBehavior(Sandbox.Model)">
            <summary>
            Check if explosion behavior exists for this model. This is stored in the "explosion_behavior" data key.
            </summary>
        </member>
        <member name="T:Sandbox.ModelPropData">
            <summary>
            The prop_data field from the model
            </summary>
        </member>
        <member name="T:Sandbox.ModelExplosionBehavior">
            <summary>
            The explosion_behavior field from the model
            </summary>
        </member>
        <member name="T:Sandbox.SurfaceExtension">
            <summary>
            Extensions for Surfaces
            </summary>
        </member>
        <member name="M:Sandbox.SurfaceExtension.DoBulletImpact(Sandbox.Surface,Sandbox.TraceResult)">
            <summary>
            Create a particle effect and play an impact sound for this surface being hit by a bullet
            </summary>
        </member>
        <member name="M:Sandbox.SurfaceExtension.DoFootstep(Sandbox.Surface,Sandbox.Entity,Sandbox.TraceResult,System.Int32,System.Single)">
            <summary>
            Create a footstep effect
            </summary>
        </member>
        <member name="T:Sandbox.VertexBufferExtenison">
            <summary>
            Extensions for Surfaces
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.Add(Sandbox.VertexBuffer,Vector3)">
            <summary>
            Add a vertex using this postion and everything else from Default
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.Add(Sandbox.VertexBuffer,Vector3,Vector2)">
            <summary>
            Add a vertex using this postion and uv, and everything else from Default
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.AddTriangle(Sandbox.VertexBuffer,Sandbox.Vertex,Sandbox.Vertex,Sandbox.Vertex)">
            <summary>
            Add a triangle to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.AddQuad(Sandbox.VertexBuffer,Rect)">
            <summary>
            Add a quad to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.AddQuad(Sandbox.VertexBuffer,Sandbox.Vertex,Sandbox.Vertex,Sandbox.Vertex,Sandbox.Vertex)">
            <summary>
            Add a quad to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.AddQuad(Sandbox.VertexBuffer,Vector3,Vector3,Vector3,Vector3)">
            <summary>
            Add a quad to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.AddQuad(Sandbox.VertexBuffer,Ray,Vector3,Vector3)">
            <summary>
            Add a quad to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBufferExtenison.AddCube(Sandbox.VertexBuffer,Vector3,Vector3,Rotation)">
            <summary>
            Add a cube to the vertex buffer. Will include indices if they're enabled.
            </summary>
        </member>
        <member name="T:Sandbox.Game">
            <summary>
            This is the main base game
            </summary>
        </member>
        <member name="M:Sandbox.Game.Shutdown">
            <summary>
            Called when the game is shutting down
            </summary>
        </member>
        <member name="M:Sandbox.Game.ClientJoined(Sandbox.Client)">
            <summary>
            Client has joined the server. Create their puppets.
            </summary>
        </member>
        <member name="M:Sandbox.Game.ClientDisconnect(Sandbox.Client,Sandbox.NetworkDisconnectionReason)">
            <summary>
            Client has disconnected from the server. Remove their entities etc.
            </summary>
        </member>
        <member name="M:Sandbox.Game.Simulate(Sandbox.Client)">
            <summary>
            Called each tick.
            Serverside: Called for each client every tick
            Clientside: Called for each tick for local client. Can be called multiple times per tick.
            </summary>
        </member>
        <member name="M:Sandbox.Game.FrameSimulate(Sandbox.Client)">
            <summary>
            Called each frame on the client only to simulate things that need to be updated every frame. An example
            of this would be updating their local pawn's look rotation so it updates smoothly instead of at tick rate.
            </summary>
        </member>
        <member name="M:Sandbox.Game.CanHearPlayerVoice(Sandbox.Client,Sandbox.Client)">
            <summary>
            Should we send voice data to this player
            </summary>
        </member>
        <member name="M:Sandbox.Game.FindActiveCamera">
            <summary>
            Which camera should we be rendering from?
            </summary>
        </member>
        <member name="M:Sandbox.Game.DoPlayerNoclip(Sandbox.Client)">
            <summary>
            Player typed kill in the console. Override if you don't want players
            to be allowed to kill themselves.
            </summary>
        </member>
        <member name="M:Sandbox.Game.DoPlayerDevCam(Sandbox.Client)">
            <summary>
            The player wants to enable the devcam. Probably shouldn't allow this
            unless you're in a sandbox mode or they're a dev.
            </summary>
        </member>
        <member name="M:Sandbox.Game.BuildCamera(Sandbox.CameraSetup)">
            <summary>
            Called to set the camera up, clientside only.
            </summary>
        </member>
        <member name="M:Sandbox.Game.BuildInput(Sandbox.InputBuilder)">
            <summary>\
            Clientside only. Called every frame to process the input.
            The results of this input are encoded into a user command and
            passed to the PlayerController both clientside and serverside.
            This routine is mainly responsible for taking input from mouse/controller
            and building look angles and move direction.
            </summary>
        </member>
        <member name="M:Sandbox.Game.PostCameraSetup(Sandbox.CameraSetup@)">
            <summary>
            Called after the camera setup logic has run. Allow the gamemode to 
            do stuff to the camera, or using the camera. Such as positioning entities 
            relative to it, like viewmodels etc.
            </summary>
        </member>
        <member name="M:Sandbox.Game.PostLevelLoaded">
            <summary>
            Called right after the level is loaded and all entities are spawned.
            </summary>
        </member>
        <member name="M:Sandbox.Game.OnVoicePlayed(System.UInt64,System.Single)">
            <summary>
            Someone is speaking via voice chat. This might be someone in your game, 
            or in your party, or in your lobby.
            </summary>
        </member>
        <member name="M:Sandbox.Game.MoveToSpawnpoint(Sandbox.Entity)">
            <summary>
            This entity is probably a pawn, and would like to be placed on a spawnpoint.
            If you were making a team based game you'd want to choose the spawn based on team.
            Or not even call this. Up to you. Added as a convenience.
            </summary>
        </member>
        <member name="M:Sandbox.Game.OnKilled(Sandbox.Entity)">
            <summary>
            An entity has been killed. This is usually a pawn but anything can call it.
            </summary>
        </member>
        <member name="M:Sandbox.Game.OnKilled(Sandbox.Client,Sandbox.Entity)">
            <summary>
            An entity, which is a pawn, and has a client, has been killed.
            </summary>
        </member>
        <member name="M:Sandbox.Game.OnKilledMessage(System.UInt64,System.String,System.UInt64,System.String,System.String)">
            <summary>
            Called clientside from OnKilled on the server to add kill messages to the killfeed. 
            </summary>
        </member>
        <member name="T:Sandbox.MoveHelper">
            <summary>
            This is the HL2 style movement. If moving from position using Velocity results
            in a collision velocity will be changed to slide across the surface where 
            appropriate. Position will be updated to the optimal position.
            
             This is coded to be simple on purpose. It's enough to get your started. Once you
             reach the point where it's lacking you should copy and paste it into your project
             and specialize to your needs.
            
            Give it a position and velocity, set the Trace up how you want to 
            use it, then you're good to go.
            
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.#ctor(Vector3,Vector3)">
            <summary>
            Create the movehelper and initialize it with the default settings. 
            You can change Trace and MaxStandableAngle after creation.
            </summary>
            <example>
            var move = new MoveHelper( Position, Velocity )
            </example>
        </member>
        <member name="M:Sandbox.MoveHelper.TraceFromTo(Vector3,Vector3)">
            <summary>
            Trace this from one position to another
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.TraceDirection(Vector3)">
            <summary>
            Trace this from its current Position to a delta
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.TryMove(System.Single)">
            <summary>
            Try to move to the position. Will return the fraction of the desired velocity that we travelled.
            Position and Velocity will be what we recommend using.
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.IsFloor(Sandbox.TraceResult)">
            <summary>
            Return true if this is the trace is a floor. Checks hit and normal angle.
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.ApplyFriction(System.Single,System.Single)">
            <summary>
            Apply an amount of friction to the velocity
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.TraceMove(Vector3)">
            <summary>
            Move our position by this delta using trace. If we hit something we'll stop, 
            we won't slide across it nicely like TryMove does.
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.TryMoveWithStep(System.Single,System.Int32)">
            <summary>
            Like TryMove but will also try to step up if it hits a wall
            </summary>
        </member>
        <member name="M:Sandbox.MoveHelper.TryUnstuck">
            <summary>
            Test whether we're stuck, and if we are then unstuck us
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.MoveHelper.Unstuck">
            <summary>
            We're inside something solid, lets try to get out of it.
            </summary>
        </member>
        <member name="T:Sandbox.VelocityClipPlanes">
            <summary>
            Used to store a list of planes that an object is going to hit, and then
            remove velocity from them so the object can slide over the surface without
            going through any of the planes.
            </summary>
        </member>
        <member name="P:Sandbox.VelocityClipPlanes.Max">
            <summary>
            Maximum number of plasnes that can be hit
            </summary>
        </member>
        <member name="P:Sandbox.VelocityClipPlanes.Count">
            <summary>
            Number of planes we're currently holding
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.TryAdd(Vector3,Vector3@,System.Single)">
            <summary>
            Try to add this plane and restrain velocity to it (and its brothers)
            </summary>
            <returns>False if we ran out of room and should stop adding planes</returns>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.TryClip(Vector3@)">
            <summary>
            Try to clip our velocity to all the planes, so we're not travelling into them
            Returns true if we clipped properly
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.MovingTowardsAnyPlane(Vector3,System.Int32)">
            <summary>
            Returns true if we're moving towards any of our planes (except for skip)
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.StartBump(Vector3)">
            <summary>
            Start a new bump. Clears planes and resets BumpVelocity
            </summary>
        </member>
        <member name="M:Sandbox.VelocityClipPlanes.ClipVelocity(Vector3,Vector3,System.Single)">
            <summary>
            Clip the velocity to the normal
            </summary>
        </member>
        <member name="F:Sandbox.BasePlayerController.TraceOffset">
            <summary>
            Any bbox traces we do will be offset by this amount.
            todo: this needs to be predicted
            </summary>
        </member>
        <member name="M:Sandbox.BasePlayerController.TraceBBox(Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Traces the bbox and returns the trace result.
            LiftFeet will move the start position up by this amount, while keeping the top of the bbox at the same 
            position. This is good when tracing down because you won't be tracing through the ceiling above.
            </summary>
        </member>
        <member name="M:Sandbox.BasePlayerController.TraceBBox(Vector3,Vector3,System.Single)">
            <summary>
            This calls TraceBBox with the right sized bbox. You should derive this in your controller if you 
            want to use the built in functions
            </summary>
        </member>
        <member name="M:Sandbox.BasePlayerController.GetHull">
            <summary>
            This is temporary, get the hull size for the player's collision
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.GetHull">
            <summary>
            This is temporary, get the hull size for the player's collision
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.UpdateBBox">
            <summary>
            Update the size of the bbox. We should really trigger some shit if this changes.
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.Accelerate(Vector3,System.Single,System.Single,System.Single)">
            <summary>
            Add our wish direction and speed onto our velocity
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.ApplyFriction(System.Single)">
            <summary>
            Remove ground friction from velocity
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.UpdateGroundEntity(Sandbox.TraceResult)">
            <summary>
            We have a new ground entity
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.ClearGroundEntity">
            <summary>
            We're no longer on the ground, remove it
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.TraceBBox(Vector3,Vector3,System.Single)">
            <summary>
            Traces the current bbox and returns the result.
            liftFeet will move the start position up by this amount, while keeping the top of the bbox at the same 
            position. This is good when tracing down because you won't be tracing through the ceiling above.
            </summary>
        </member>
        <member name="M:Sandbox.WalkController.StayOnGround">
            <summary>
            Try to keep a walking player on the ground when running down slopes etc
            </summary>
        </member>
        <member name="M:Sandbox.UI.Button.SetText(System.String)">
            <summary>
            Calls Text = value
            </summary>
        </member>
        <member name="P:Sandbox.UI.Tests.GridLayout.ItemSize">
            <summary>
            The fixed size of each item. If x is lower than 0 then we'll stretch to fill the size.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Tests.GridLayout.AutoColumns">
            <summary>
            Should we update Columns automatically?
            </summary>
        </member>
        <member name="P:Sandbox.UI.Tests.GridLayout.Columns">
            <summary>
            How many columns should we have?
            </summary>
        </member>
        <member name="P:Sandbox.UI.Tests.GridLayout.Rect">
            <summary>
            The Rect of this layout. Set via Update.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Tests.GridLayout.ScrollOffset">
            <summary>
            Where the top of the visible space is
            </summary>
        </member>
        <member name="P:Sandbox.UI.Tests.GridLayout.Justify">
            <summary>
            How columns should be justified
            </summary>
        </member>
        <member name="M:Sandbox.UI.Tests.GridLayout.Update(Rect,System.Single,Sandbox.UI.Justify)">
            <summary>
            Update specifics of this layout. Returns true if we're dirty.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Tests.GridLayout.GetVisibleRange(System.Int32@,System.Int32@)">
            <summary>
            Get the range of cells that are visible
            </summary>
        </member>
        <member name="M:Sandbox.UI.Tests.GridLayout.GetPosition(System.Int32)">
            <summary>
            Get the position of this cell
            </summary>
        </member>
        <member name="M:Sandbox.UI.Tests.GridLayout.Position(System.Int32,Sandbox.UI.Panel)">
            <summary>
            Move this panel into the position. This will set the Left/Top/Width/Height on the panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Tests.GridLayout.GetHeight(System.Int32)">
            <summary>
            Get the full height if we have this many items
            </summary>
        </member>
        <member name="T:Sandbox.UI.Tests.VirtualScrollPanel">
            <summary>
            Scroll panel that creates its contents as they become visible
            
            TODO: we need to let panels know, or recreate them, when Data changes
            
            </summary>
        </member>
        <member name="M:Sandbox.UI.Tests.VirtualScrollPanel.HasData(System.Int32)">
            <summary>
            Return true if we have this data slot
            </summary>
        </member>
        <member name="P:Sandbox.UI.Tests.VirtualScrollPanel.OnCreateCell">
            <summary>
            Create a new panel. You should add a child to the passed panel (which is the cell).
            </summary>
        </member>
        <member name="P:Sandbox.UI.TextEntry.AutoComplete">
            <summary>
            If you hook a method up here we'll do autocomplete on it
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextEntry.TimeSinceNotInFocus">
            <summary>
            Keep tabs of when we were focused so we can flash the caret rative to that time.
            We want the caret to be visible immediately on focus
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.CanAdd(Sandbox.Entity)">
            <summary>
            Return true if this item belongs in the inventory
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.DeleteContents">
            <summary>
            Delete every entity we're carrying. Useful to call on death.
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.GetSlot(System.Int32)">
            <summary>
            Get the item in this slot
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.Count">
            <summary>
            Returns the number of items in the inventory
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.GetActiveSlot">
            <summary>
            Returns the index of the currently active child
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.Pickup(Sandbox.Entity)">
            <summary>
            Try to pick this entity up
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.OnChildAdded(Sandbox.Entity)">
            <summary>
            A child has been added to the Owner (player). Do we want this
            entity in our inventory? Yeah? Add it then.
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.OnChildRemoved(Sandbox.Entity)">
            <summary>
            A child has been removed from our Owner. This might not even
            be in our inventory, if it is then we'll remove it from our list
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.SetActiveSlot(System.Int32,System.Boolean)">
            <summary>
            Set our active entity to the entity on this slot
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.SwitchActiveSlot(System.Int32,System.Boolean)">
            <summary>
            Switch to the slot next to the slot we have active.
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.DropActive">
            <summary>
            Drop the active entity. If we can't drop it, will return null
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.Drop(Sandbox.Entity)">
            <summary>
            Drop this entity. Will return true if successfully dropped.
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.Contains(Sandbox.Entity)">
            <summary>
            Returns true if this inventory contains this entity
            </summary>
        </member>
        <member name="P:Sandbox.BaseInventory.Active">
            <summary>
            Returns the active entity
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.SetActive(Sandbox.Entity)">
            <summary>
            Make this entity the active one
            </summary>
        </member>
        <member name="M:Sandbox.BaseInventory.Add(Sandbox.Entity,System.Boolean)">
            <summary>
            Try to add this entity to the inventory. Will return true
            if the entity was added successfully. 
            </summary>
        </member>
        <member name="T:Sandbox.Breakables">
            <summary>
            Handle breaking a prop into bits
            </summary>
        </member>
        <member name="T:Sandbox.EntityLimit">
            <summary>
            A class that limits the amount of entities.
            </summary>
        </member>
        <member name="P:Sandbox.EntityLimit.MaxTotal">
            <summary>
            Maximum entities in this list before we start deleting
            </summary>
        </member>
        <member name="P:Sandbox.EntityLimit.List">
            <summary>
            List of entities currently in this shit
            </summary>
        </member>
        <member name="M:Sandbox.EntityLimit.Watch(Sandbox.ModelEntity)">
            <summary>
            Watch an entity, contribute to the count and delete when its their turn
            </summary>
        </member>
        <member name="M:Sandbox.EntityLimit.Maintain">
            <summary>
            Maintain the list, delete entities if they need deleting
            </summary>
        </member>
        <member name="M:Sandbox.EntityLimit.Retire(Sandbox.Entity)">
            <summary>
            Delete this entity and remove it from the list
            </summary>
        </member>
    </members>
</doc>
